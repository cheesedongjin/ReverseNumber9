<!DOCTYPE html>
<html lang="en">
<head>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-8JZ9J4MT22"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-8JZ9J4MT22');
</script>
<meta charset="UTF-8">
<title>ReverseNumber9</title>
<link rel="stylesheet" href="style.css">
</head>
<body>
<nav><a href="other-sites/addresses">Other Sites by Jdeseech</a></nav>
<div class="container">
<h1>ReverseNumber9</h1>
<section>
<h2>Record</h2>
<button id="recordBtn">Start Recording</button>
<button id="stopBtn" disabled>Stop Recording</button>
<button id="playBtn" disabled>Play</button>
<button id="reversePlayBtn" disabled>Play Reversed</button>
<span id="recordingStatus">Recording...</span>
<a id="downloadLink" download="recording.wav">Download</a>
<a id="reverseDownloadLink" download="recording_reversed.wav">Download Reversed</a>
</section>
</div>
<script>
let mediaRecorder;
let recordedChunks = [];
let recordedBlob;
let currentAudio;

const recordBtn = document.getElementById('recordBtn');
const stopBtn = document.getElementById('stopBtn');
const playBtn = document.getElementById('playBtn');
const reversePlayBtn = document.getElementById('reversePlayBtn');
const downloadLink = document.getElementById('downloadLink');
const reverseDownloadLink = document.getElementById('reverseDownloadLink');
const recordingStatus = document.getElementById('recordingStatus');

recordBtn.onclick = async () => {
  try {
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    mediaRecorder = new MediaRecorder(stream);
    recordedChunks = [];
    mediaRecorder.ondataavailable = e => recordedChunks.push(e.data);
    mediaRecorder.onstop = e => {
      recordedBlob = new Blob(recordedChunks);
      playBtn.disabled = false;
      reversePlayBtn.disabled = false;
      downloadLink.href = URL.createObjectURL(recordedBlob);
      downloadLink.style.display = 'inline';
      createReversedBlob(recordedBlob).then(blob => {
        reverseDownloadLink.href = URL.createObjectURL(blob);
        reverseDownloadLink.style.display = 'inline';
      });
      recordingStatus.style.display = 'none';
    };
    mediaRecorder.start();
    recordingStatus.style.display = 'inline';
    recordBtn.disabled = true;
    stopBtn.disabled = false;
  } catch (err) {
    console.error('Unable to access microphone:', err);
    alert('Could not start recording. Check your microphone permissions.');
  }
};

stopBtn.onclick = () => {
  if (mediaRecorder && mediaRecorder.state !== 'inactive') {
    mediaRecorder.stop();
  }
  recordBtn.disabled = false;
  stopBtn.disabled = true;
  recordingStatus.style.display = 'none';
};

function stopCurrentAudio() {
  if (currentAudio) {
    if (typeof currentAudio.pause === 'function') {
      currentAudio.pause();
    } else if (typeof currentAudio.stop === 'function') {
      try { currentAudio.stop(); } catch (e) {}
    }
    currentAudio = null;
  }
}

function playBlobReversed(blob) {
  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  blob.arrayBuffer().then(buf => audioCtx.decodeAudioData(buf, audioBuf => {
    for (let i = 0; i < audioBuf.numberOfChannels; i++) {
      Array.prototype.reverse.call(audioBuf.getChannelData(i));
    }
    const source = audioCtx.createBufferSource();
    source.buffer = audioBuf;
    source.connect(audioCtx.destination);
    source.onended = () => {
      if (currentAudio === source) currentAudio = null;
    };
    stopCurrentAudio();
    currentAudio = source;
    source.start();
  }));
}

function audioBufferToWav(buffer) {
  const numOfChan = buffer.numberOfChannels;
  const length = buffer.length * numOfChan * 2 + 44;
  const bufferArray = new ArrayBuffer(length);
  const view = new DataView(bufferArray);
  let pos = 0;

  const writeString = s => { for (let i = 0; i < s.length; i++) view.setUint8(pos++, s.charCodeAt(i)); };
  const writeUint16 = d => { view.setUint16(pos, d, true); pos += 2; };
  const writeUint32 = d => { view.setUint32(pos, d, true); pos += 4; };

  writeString('RIFF');
  writeUint32(length - 8);
  writeString('WAVE');
  writeString('fmt ');
  writeUint32(16);
  writeUint16(1);
  writeUint16(numOfChan);
  writeUint32(buffer.sampleRate);
  writeUint32(buffer.sampleRate * numOfChan * 2);
  writeUint16(numOfChan * 2);
  writeUint16(16);
  writeString('data');
  writeUint32(length - pos - 4);

  const channels = [];
  for (let i = 0; i < numOfChan; i++) channels.push(buffer.getChannelData(i));

  let offset = 0;
  while (pos < length) {
    for (let i = 0; i < numOfChan; i++) {
      let sample = Math.max(-1, Math.min(1, channels[i][offset]));
      sample = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
      view.setInt16(pos, sample, true);
      pos += 2;
    }
    offset++;
  }

  return new Blob([bufferArray], { type: 'audio/wav' });
}

function createReversedBlob(blob) {
  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  return blob.arrayBuffer()
    .then(buf => audioCtx.decodeAudioData(buf))
    .then(audioBuffer => {
      for (let i = 0; i < audioBuffer.numberOfChannels; i++) {
        Array.prototype.reverse.call(audioBuffer.getChannelData(i));
      }
      return audioBufferToWav(audioBuffer);
    });
}

playBtn.onclick = () => {
  stopCurrentAudio();
  const url = URL.createObjectURL(recordedBlob);
  currentAudio = new Audio(url);
  const audio = currentAudio;
  audio.onended = () => { if (currentAudio === audio) currentAudio = null; };
  audio.play();
};

reversePlayBtn.onclick = () => {
  playBlobReversed(recordedBlob);
};

</script>
</body>
</html>
